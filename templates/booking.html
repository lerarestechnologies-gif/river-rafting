{% extends "base.html" %}
{% block content %}
<div class="max-w-2xl mx-auto bg-white p-6 rounded shadow">
  <h2 class="text-xl font-bold mb-4">Book Slot</h2>
  <form method="POST">
    <input name="name" placeholder="Full name" class="border p-2 w-full mb-2" required>
    <input name="email" placeholder="Email" type="email" class="border p-2 w-full mb-2" required>
    <label class="block mb-1 font-medium">Phone Number</label>

    <div class="flex mb-2">
      <!-- Country code -->
      <span class="inline-flex items-center px-3 border border-r-0 rounded-l bg-gray-100 text-gray-700">
        +91
      </span>

      <!-- Phone input -->
      <input type="tel" name="phone" placeholder="10-digit whatsapp number"
        class="border border-l-0 rounded-r p-2 w-full focus:outline-none focus:ring-2 focus:ring-teal-500"
        pattern="[0-9]{10}" minlength="10" maxlength="10" inputmode="numeric" required
        title="Please enter a valid 10-digit phone number">
    </div>

    <p class="text-sm text-gray-500 mb-2">
      Enter your whatsapp number.
    </p>

    <div class="mb-4 bg-blue-50 p-4 rounded text-sm text-gray-800">
      <h3 class="font-bold mb-2">Instructions:</h3>
      <ul class="list-disc pl-5 space-y-1">
        <li>If the group size is below 4 and the accompanying group cancels, your booking may also be cancelled, as a
          minimum of 4 participants is required in a raft for weight balance and safety.</li>
        <li>This is a rain-dependent activity. Water levels may vary. We will notify you one day in advance.</li>
        <li>Cancellation or postponement is allowed in such rain/water level cases, and a refund will be issued.</li>
      </ul>
    </div>

    <div class="relative mb-2">
      <input id="booking_date" name="booking_date" type="text" class="border p-2 w-full pr-10"
        placeholder="Select a date" required autocomplete="off" />
      <button type="button" id="booking_date_btn" aria-label="Open calendar"
        class="absolute right-2 top-1/2 transform -translate-y-1/2 text-gray-600">
        <!-- simple calendar icon -->
        ðŸ“…
      </button>
    </div>
    <small class="text-muted">Select a date between {{ min_date }} and {{ max_date }} (inclusive)</small>
    <label class="block mb-1">Slot</label>
    <select name="slot" id="slot-select" class="border p-2 w-full mb-2" required>
      {% for s in settings.time_slots %}
      <option value="{{ s }}">{{ s }}</option>
      {% endfor %}
    </select>
    <input name="group_size" type="number" min="1"
      max="{{ settings.normal_max_people_per_slot if settings and settings.normal_max_people_per_slot else 30 }}"
      class="border p-2 w-full mb-2" placeholder="Group size" required>
    <p class="text-xs text-gray-600 mb-2">
      Maximum per slot: {{ settings.normal_max_people_per_slot }}.
      Bulk booking (empty slot only): up to {{ settings.bulk_max_people_per_slot }}.
    </p>
    <div class="text-center"><button class="bg-teal-600 text-white px-4 py-2 rounded">Confirm Booking</button></div>
  </form>
</div>

<script>
  // Listen for settings updates from other tabs/windows
  window.addEventListener('storage', function (e) {
    if (e.key === 'settings_updated') {
      // Reload page to get fresh settings (time slots, max people, etc.)
      window.location.reload();
    }
  });

  // Use Flatpickr to get per-day disable support and better UX
</script>

<!-- Flatpickr CSS/JS (CDN). If offline, flatpickr will fail gracefully and native input will be used. -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
<script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
<style>
  /* Grey out disabled dates and show not-allowed cursor */
  .flatpickr-day.flatpickr-disabled {
    color: #9CA3AF !important;
    /* gray-400 */
    cursor: not-allowed !important;
    text-decoration: line-through;
    opacity: 0.65;
  }
</style>

<script>
  window.fpInstance = window.fpInstance || null;
  window.fpDisabledDates = window.fpDisabledDates || [];

  document.addEventListener('DOMContentLoaded', function () {
    const dateInput = document.getElementById('booking_date');
    // const noticeEl = document.getElementById('unavailableDatesNotice');

    // Config from server-side template
    const minDate = '{{ min_date }}';
    const maxDate = '{{ max_date }}';

    // Initialize flatpickr immediately, then fetch unavailable dates asynchronously
    function initDatepicker() {
      // 1. Initialize flatpickr immediately with empty disabled list
      try {
        window.fpInstance = flatpickr(dateInput, {
          altInput: true,
          altFormat: 'd-m-Y',
          dateFormat: 'Y-m-d',
          allowInput: false,
          minDate: minDate,
          maxDate: maxDate,
          disable: [], // Start empty, update later
          disableMobile: true,
          onChange: function (selectedDates, dateStr, instance) {
            if (!dateStr) return;
            // Native flatpickr disabling prevents selection, but we keep this check just in case
            // checking against the live config which is updated after fetch
            const currentDisabled = instance.config.disable || [];
            if (currentDisabled.some(d => d === dateStr)) {
              alert('Selected date is fully booked. Please choose another date.');
              instance.clear();
              if (typeof updateSlotAvailability === 'function') {
                updateSlotAvailability(null);
              }
              return;
            }
            if (typeof updateSlotAvailability === 'function') {
              updateSlotAvailability(dateStr);
            }
          }
        });

        // Wire calendar button
        const calBtn = document.getElementById('booking_date_btn');
        if (calBtn) {
          calBtn.addEventListener('click', function () {
            if (window.fpInstance) {
              window.fpInstance.open();
            }
          });
        }
      } catch (err) {
        console.error('Flatpickr init failed', err);
        // Fallback
        try {
          dateInput.setAttribute('type', 'date');
          dateInput.setAttribute('min', minDate);
          dateInput.setAttribute('max', maxDate);
        } catch (e) { }
      }

      // 2. Fetch unavailable dates in background
      fetch('/fully_booked_dates')
        .then(res => res.json())
        .then(data => {
          if (data.fully_booked_dates && window.fpInstance) {
            window.fpDisabledDates = data.fully_booked_dates;
            // Update the calendar instance with new disabled dates
            window.fpInstance.set('disable', window.fpDisabledDates);
            // Redraw to reflect changes immediately
            window.fpInstance.redraw();
          }
        })
        .catch(err => console.error('Failed to fetch fully filled dates', err));
    }

    initDatepicker();
  });
</script>

<script>
  // Keep a map of slot availability for the selected date
  let slotAvailMap = {};

  async function updateSlotAvailability(day) {
    const slotSelect = document.getElementById('slot-select');
    const groupSizeInput = document.querySelector('input[name="group_size"]');
    // Reset all options if no day provided
    if (!slotSelect) return;
    if (!day) {
      const loadingOption = slotSelect.querySelector('option[data-loading]');
      if (loadingOption) {
        slotSelect.removeChild(loadingOption);
      }
      slotSelect.disabled = false;
      // enable all options
      Array.from(slotSelect.options).forEach(opt => {
        opt.disabled = false;
        opt.style.color = '';
      });
      if (groupSizeInput) {
        // reset max to original calculated value (based on settings)
        groupSizeInput.removeAttribute('max');
      }
      slotAvailMap = {};
      return;
    }

    // Show lightweight loading state while fetching availability
    let loadingOption = slotSelect.querySelector('option[data-loading]');
    if (!loadingOption) {
      loadingOption = document.createElement('option');
      loadingOption.value = '';
      loadingOption.textContent = 'Updating availability...';
      loadingOption.disabled = true;
      loadingOption.setAttribute('data-loading', 'true');
      slotSelect.insertBefore(loadingOption, slotSelect.firstChild);
    }
    slotSelect.disabled = true;
    slotSelect.value = loadingOption.value;

    try {
      const res = await fetch('/slot_availability?day=' + encodeURIComponent(day));
      if (!res.ok) {
        console.error('Failed to fetch slot availability');
        return;
      }
      const json = await res.json();
      slotAvailMap = json || {};

      // Update slot options
      Array.from(slotSelect.options).forEach(opt => {
        const val = opt.value;
        const info = slotAvailMap[val];
        if (info && info.full) {
          opt.disabled = true;
          opt.style.color = '#9CA3AF';
        } else {
          opt.disabled = false;
          opt.style.color = '';
        }
      });

      // If current selection is disabled, pick first available
      if (slotSelect.value) {
        const curOpt = slotSelect.options[slotSelect.selectedIndex];
        if (curOpt && curOpt.disabled) {
          // choose first available
          const avail = Array.from(slotSelect.options).find(o => !o.disabled);
          if (avail) slotSelect.value = avail.value;
          else slotSelect.value = '';
        }
      }

      // Update group_size max to available seats for selected slot if possible
      if (groupSizeInput && slotSelect.value) {
        const selInfo = slotAvailMap[slotSelect.value];
        if (selInfo) {
          // allow up to available seats (but not exceed original templated max)
          const avail = selInfo.available || 0;
          if (avail > 0) {
            groupSizeInput.max = avail;
          } else {
            groupSizeInput.max = 0;
          }
        }
      }
    } catch (err) {
      console.error('Error updating slot availability', err);
    } finally {
      slotSelect.disabled = false;
      loadingOption = slotSelect.querySelector('option[data-loading]');
      if (loadingOption) {
        slotSelect.removeChild(loadingOption);
      }
    }
  }

  // When slot changes, update group size max accordingly (bind once)
  document.addEventListener('DOMContentLoaded', function () {
    const slotSelect = document.getElementById('slot-select');
    const groupSizeInput = document.querySelector('input[name="group_size"]');
    if (!slotSelect || !groupSizeInput) return;

    slotSelect.addEventListener('change', function () {
      if (!slotAvailMap) return;
      const info = slotAvailMap[this.value];
      if (info) {
        groupSizeInput.max = info.available || 0;
      } else {
        groupSizeInput.removeAttribute('max');
      }
    });
  });

  // Helper to refresh disabled dates and slot availability when returning
  // to the page via back/forward navigation.
  function refreshAvailability() {
    const dateInput = document.getElementById('booking_date');
    const selectedDate = dateInput ? dateInput.value : null;

    // Refresh disabled dates for Flatpickr
    if (window.fpInstance) {
      fetch('/fully_booked_dates')
        .then(res => res.json())
        .then(data => {
          if (data.fully_booked_dates && window.fpInstance) {
            window.fpDisabledDates = data.fully_booked_dates;
            window.fpInstance.set('disable', window.fpDisabledDates);
            window.fpInstance.redraw();
          }
          // If a date is already selected, refresh slot availability for that day
          if (selectedDate && typeof updateSlotAvailability === 'function') {
            updateSlotAvailability(selectedDate);
          }
        })
        .catch(err => console.error('Failed to refresh availability', err));
    } else if (selectedDate && typeof updateSlotAvailability === 'function') {
      // Even if fpInstance is not ready, ensure slots are current
      updateSlotAvailability(selectedDate);
    }
  }

  // Handle browser back/forward cache restores so the page always shows
  // fresh availability without a full reload.
  window.addEventListener('pageshow', function (event) {
    if (event.persisted) {
      if (typeof refreshAvailability === 'function') {
        refreshAvailability();
      }
    }
  });
</script>
{% endblock %}